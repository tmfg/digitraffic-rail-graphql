type Query {
    train(trainNumber : Int!, departureDate : Date!) : [Train]
    trainsByDepartureDate(departureDate : Date!) : [Train]
    trainsByVersionGreaterThan(version : String!) : [Train]
    trainsByStationAndQuantity(station : String!, arrivedTrains : Int, arrivingTrains : Int,departedTrains : Int,departingTrains : Int, includeNonStopping : Boolean, trainCategories : [String]) : [Train]
    currentlyRunningTrains : [Train]

    latestTrainLocations : [TrainLocation]

    compositionsGreaterThanVersion(version : String!) : [Composition]

    trainTrackingMessagesByVersionGreaterThan(version : String!) : [TrainTrackingMessage]

    routesetMessagesByVersionGreaterThan(version : String!) : [RoutesetMessage]

    stations: [Station]
}

type Train {
    cancelled : Boolean!
    commuterLineid : String
    deleted : Boolean
    departureDate : Date!
    operatorShortCode : String!
    runningCurrently : Boolean!
    timetableAcceptanceDate : DateTime!
    timetableType : TimetableType!
    trainNumber : Int!
    version : String!
    trainTypeId : Int!
    trainCategoryId : Int!
    operator : Operator!
    trainType : TrainType!
    timeTableRows : [TimeTableRow]
    trainLocations : [TrainLocation]
    compositions : [Composition]
    trainTrackingMessages : [TrainTrackingMessage]
    routesetMessages: [RoutesetMessage]
}

type TrainType {
    id : Int!
    name : String!
    trainCategoryId : Int!
    trainCategory : TrainCategory!
}

type TrainCategory {
    id : Int!
    name : String!
}

type TimeTableRow {
    stationShortCode : String!
    stationUICCode : Int!
    countryCode : String!
    type : TimeTableRowType!
    trainStopping : Boolean!
    commercialStop : Boolean
    commercialTrack : String
    cancelled : Boolean!
    scheduledTime : DateTime!
    actualTime : DateTime
    differenceInMinutes : Int
    liveEstimateTime : DateTime
    estimateSourceType : EstimateSourceType
    unknownDelay : Boolean

    id : Int!
    trainNumber : Int!
    departureDate : Date!

    station : Station!
    train: Train!
    causes : [Cause]
}

type Cause {
    timeTableRowId : Int!
    trainNumber : Int!
    departureDate : Date!

    id : Int!
    categoryCodeOid : String!
    detailedCategoryCodeOid : String
    thirdCategoryCodeOid : String
    categoryCode : CategoryCode!
    detailedCategoryCode : DetailedCategoryCode
    thirdCategoryCode : ThirdCategoryCode
}

type Operator {
    name : String!
    shortCode : String!
    uicCode : Int!
}

type TrainLocation {
    departureDate : Date!
    speed : Int!
    accuracy: Int
    timestamp : DateTime!
    trainNumber : Int!
    location : [Float]
    train : Train
}

type Composition {
    departureDate : Date!
    trainNumber : Int!
    operatorShortCode : String!
    trainCategoryId : Int!
    trainTypeId : Int!
    version : String!
    operatorUicCode : Int!
    train : Train
    journeySections : [JourneySection]
}

type JourneySection {
    id : Int!
    departureDate : Date!
    trainNumber : Int!
    beginTimeTableRowId : Int
    endTimeTableRowId : Int
    maximumSpeed : Int!
    totalLength : Int!
    startTimeTableRow : TimeTableRow
    endTimeTableRow : TimeTableRow
    wagons : [Wagon]
    locomotives : [Locomotive]
}

type Locomotive {
    id : Int!
    location : Int!
    locomotiveType : String!
    powerTypeAbbreviation : String!
    journeysectionId : Int!
    vehicleNumber : String
}

type Wagon {
    id : Int!
    length : Int!
    location : Int!
    salesNumber : Int!
    journeysectionId : Int!
    catering : Boolean
    disabled : Boolean
    luggage : Boolean
    pet : Boolean
    playground : Boolean
    smoking : Boolean
    video : Boolean
    wagonType : String
    vehicleNumber : String
}

type Station {
    id : Int!
    passengerTraffic : Boolean!
    countryCode : String!
    location : [Float]
    name : String!
    shortCode : String!
    uicCode : Int!
    type : StationType!
    timeTableRows: [TimeTableRow]
}

type CategoryCode {
    code : String!
    name : String!
    oid : String!
    validFrom : Date!
    validTo : Date
}

type DetailedCategoryCode {
    code : String!
    name : String!
    oid : String!
    categoryCodeOid : String!
    validFrom : Date!
    validTo : Date
}

type ThirdCategoryCode {
    code : String!
    name : String!
    description : String!
    oid : String!
    validFrom : Date!
    validTo : Date
    detailedCategoryCodeOid : String!
}

type TrainTrackingMessage {
    id : Int!
    trainNumber : String!
    departureDate : Date!
    stationShortCode : String!
    nextStationShortCode : String
    previousStationShortCode : String
    version : String!
    timestamp : DateTime!
    trackSectionCode : String!
    nextTrackSectionCode : String
    previousTrackSectionCode : String
    type : TrainTrackingMessageType!
    station : Station!
    nextStation : Station
    previousStation : Station
    train : Train
    trackSection: TrackSection
}

type RoutesetMessage {
    id : Int!
    version : String!
    messageTime : DateTime!
    trainNumber : String!
    departureDate : Date
    routeType : String!
    clientSystem : String!
    routesections : [Routesection]
    train : Train
}

type Routesection {
    sectionId : String!
    commercialTrackId : String!
    stationCode : String!
    routesetId : Int!
    station : Station!
}

type TrackSection {
    id : Int!
    trackSectionCode: String!
    station: Station!
    ranges: [TrackRange]!
}

type TrackRange {
    trackSectionId: Int!
    startTrack: String!
    startKilometres: Int!
    startMetres: Int!
    endTrack: String!
    endKilometres: Int!
    endMetres: Int!
}

## SCALARS

scalar Date
scalar DateTime

## ENUMS

enum TimetableType {
    REGULAR,
    ADHOC
}
enum TimeTableRowType {
    ARRIVAL
    DEPARTURE
}

enum StationType {
    STATION, STOPPING_POINT, TURNOUT_IN_THE_OPEN_LINE
}
enum TrainTrackingMessageType {
    OCCUPY,RELEASE
}

enum OrderDirection {
    ASCENDING,
    DESCENDING
}
enum EstimateSourceType {
    LIIKE_USER,
    MIKU_USER,
    LIIKE_AUTOMATIC,
    UNKNOWN,
    COMBOCALC
}

## PRIMITIVE FILTERS

input BooleanWhere {
    equals : Boolean
    unequals : Boolean
}

input StringWhere {
    equals : String
    unequals : String
}

input IntWhere {
    equals : Int
    unequals : Int
    greaterThan : Int
    lessThan : Int
}

input EnumWhere {
    equals : String
    unequals : String
}

input DateTimeWhere {
    equals : DateTime
    unequals : DateTime
    greaterThan : DateTime
    lessThan : DateTime
}

input DateWhere {
    equals : Date
    unequals : Date
    greaterThan : Date
    lessThan : Date
}

input CoordinateWhere {
    inside : [Float]
}

input VersionWhere {
    equals : String
    unequals : String
    greaterThan : String
    lessThan : String
}
