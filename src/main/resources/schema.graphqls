type Query {
    train(trainNumber : Int, departureDate : Date) : Train
    trainsByDepartureDate(departureDate : Date, where : TrainFilter) : [Train]
    #    trainsByDepartureDateAndTrainNumberGreaterThan(departureDate : Date, trainNumberGreaterThan : Int, where : TrainFilter) : [Train]
    trainsByVersionGreaterThan(version : String, where : TrainFilter) : [Train]
    trainsByStationAndQuantity(station : String, arrivedTrains : Int, arrivingTrains : Int,departedTrains : Int,departingTrains : Int, includeNonStopping : Boolean, trainCategories : [String], where : TrainFilter) : [Train]
    trainLocations: [TrainLocation]
    compositionsGreaterThanVersion(version : String) : [Composition]
}

type Train {
    cancelled : Boolean
    commuterLineid : String
    deleted : Boolean
    departureDate : Date
    operatorShortCode : String
    runningCurrently : Boolean
    timetableAcceptanceDate : DateTime
    timetableType : TimetableType
    trainNumber : Int
    version : String
    trainTypeId : Int
    trainCategoryId : Int
    operator : Operator
    trainType : TrainType
    timeTableRows : [TimeTableRow]
    trainLocations : [TrainLocation]
    compositions : [Composition]
}

type TrainType {
    id : Int
    name : String
    trainCategoryId : Int
    trainCategory : TrainCategory
}

type TrainCategory {
    id : Int
    name : String
}

type TimeTableRow {
    stationShortCode : String
    stationUICCode : Int
    countryCode : String
    type : TimeTableRowType
    trainStopping : Boolean
    commercialStop : Boolean
    commercialTrack : String
    cancelled : Boolean
    scheduledTime : DateTime
    actualTime : DateTime

    id : Int
    trainNumber : Int
    departureDate : Date

    station: Station
    causes : [Cause]
}

type Cause {
    timeTableRowId : Int
    trainNumber : Int
    departureDate : Date

    id : Int
    categoryCodeId : Int
    detailedCategoryCodeId : Int
    thirdCategoryCodeId : Int
    categoryCode : CategoryCode
    detailedCategoryCode : DetailedCategoryCode
    thirdCategoryCode : ThirdCategoryCode
}

type Operator {
    name : String
    shortCode : String
    uicCode : Int
}

type TrainLocation {
    departureDate : Date
    speed : Int
    timestamp : DateTime
    trainNumber : Int
    location : [Float]
    train: Train
}

type Composition {
    departureDate : Date
    trainNumber : Int
    operatorShortCode : String
    trainCategoryId : Int
    trainTypeId : Int
    version : String
    operatorUicCode : Int
    train : Train
    journeySections : [JourneySection]
}

type JourneySection {
    id : Int
    departureDate : Date
    trainNumber : Int
    beginTimeTableRowId : Int
    endTimeTableRowId : Int
    maximumSpeed : Int
    totalLength : Int
    startTimeTableRow : TimeTableRow
    endTimeTableRow : TimeTableRow
    wagons : [Wagon]
    locomotives : [Locomotive]
}

type Locomotive {
    id : Int
    location : Int
    locomotiveType : String
    powerTypeAbbreviation : String
    journeysectionId : Int
    vehicleNumber : String
}

type Wagon {
    id : Int
    length : Int
    location : Int
    salesNumber : Int
    journeysectionId : Int
    catering : Boolean
    disabled : Boolean
    luggage : Boolean
    pet : Boolean
    playground : Boolean
    smoking : Boolean
    video : Boolean
    wagonType : String
    vehicleNumber : String
}

type Station {
    id : Int
    passengerTraffic : Boolean
    countryCode : String
    location : [Float]
    name : String
    shortCode : String
    uicCode : Int
    type : StationType
}

type CategoryCode {
    code : String
    name : String
    id : Int
    validFrom : Date
    validTo : Date
}

type DetailedCategoryCode {
    code : String
    name : String
    id : Int
    categoryCodeId : Int
    validFrom : Date
    validTo : Date
}

type ThirdCategoryCode {
    code : String
    name : String
    description : String
    id : Int
    validFrom : Date
    validTo : Date
    detailedCategoryCodeId : Int
}

scalar Date
scalar DateTime

enum TimetableType {
    REGULAR,
    ADHOC
}
enum TimeTableRowType {
    ARRIVAL
    DEPARTURE
}

enum StationType {
    STATION, STOPPING_POINT, TURNOUT_IN_THE_OPEN_LINE
}

input TrainFilter {
    and: [TrainFilter]
    or: [TrainFilter]

    cancelled : BooleanFilter
    commuterLineid : StringFilter
    deleted : BooleanFilter
    departureDate : DateFilter
    runningCurrently : BooleanFilter
    timetableAcceptanceDate : DateTimeFilter
    timetableType : EnumFilter
    trainNumber : IntegerFilter
    version : StringFilter
    operator : OperatorFilter
    trainType : TrainTypeFilter
    timeTableRows : TimeTableRowFilter
    #    trainLocations : [TrainLocation]
    #    compositions : [Composition]
}

input TimeTableRowFilter {
    and: [TimeTableRowFilter]
    or: [TimeTableRowFilter]
    type : EnumFilter
    trainStopping : BooleanFilter
    commercialStop : BooleanFilter
    commercialTrack : StringFilter
    cancelled : BooleanFilter
    scheduledTime : DateTimeFilter
    actualTime : DateTimeFilter
    station: StationFilter
    #    causes : [Cause]
}

input TrainTypeFilter {
    and: [TrainTypeFilter]
    or: [TrainTypeFilter]
    name : StringFilter
    #    trainCategory : TrainCategory
}

#input TimeTableRowCollectionFilter {
#    logic: FilteringLogic
#    where: TimeTableRowFilter
#}
#
#enum FilteringLogic {
#    ALL_ROWS_MATCH
#    ATLEAST_ONE_ROW_MATCHES
#}


input OperatorFilter {
    name : StringFilter
    shortCode : StringFilter
    uicCode : IntegerFilter
}

input StationFilter {
    passengerTraffic : BooleanFilter
    countryCode : StringFilter
    #    location : [Float]
    name : StringFilter
    shortCode : StringFilter
    uicCode : IntegerFilter
    type : EnumFilter
}

input BooleanFilter {
    eq : Boolean
}

input StringFilter {
    eq : String
}

input IntegerFilter {
    eq : Int
    gt : Int
    lt : Int
}

input EnumFilter {
    eq : String
}

input DateTimeFilter {
    eq: DateTime
    gt: DateTime
    lt: DateTime
}

input DateFilter {
    eq: Date
    gt: Date
    lt: Date
}
